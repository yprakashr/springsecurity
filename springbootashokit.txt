Hibernate: It is an ORM framework. Used to develop only persistence layer of our applicatipn
Struts: It is a web framework. Used to develop only web layer of our application.
Spring: It is an application development framework. Entire project can be developed by using
this.
(we can do application end to end development)

Spring Modules
1) Spring Core
2) Spring Context
3) Spring DAO / Spring JDBC
5) Spring AOP
6) Spring ORM
7) Spring Web MVC
8) Spring Security
9) Spring REST
10) Spring Data
11) Spring Cloud
12) Spring Batch etc..

Note: Spring framework is loosely coupled. It will not force to use all modules.
- Based on project requirement we can choose which modules we need to use from Spring.
Note: Spring Core is the base module for all other modules in Spring. To work with any module
in spring first we need to know Spring Core module.

- Spring Core Module is base module in Spring Framework. It is providing IOC container &
Dependency Injection.
Note: IOC & DI are fundamental concepts of Spring Framework.
-> Spring Context module will deal the configuration related stuff
-> AOP stands for Aspect Oriented Programming. Spring AOP is used deal with Cross Cutting
logics in application.
Application = Business Logic + Cross Cutting Logic
Note: We can seperate business logic and cross cutting lagic using AOP module.


-> Spring JDBC / Spring DAO module used to develop Persistence Layer
-> Spring ORM module is used to develop Persistence Layer with ORM features.
Pullup for precise seeking
-> Spring Web MVC Module is used to develop Web Applications.
-› Spring Security module is used to implement Security Features in ol
(Authentication & Authorization)
-> Spring REST is used to develop RESTFul services (REST API)
-› Spring Data is used to develop persistence layer. It provided pre-us...--
simplify CRUD operations.

Spring Advantages
-> It is a free & open source framework
-> Spring is very light weight framework
-> Spring is versatile frmework

(Spring can be integrated with any other java framework available in the market)
-> Spring is non-invasive framework
(spring framework will not force us to use framework related interfaces or classes)
Ex: To create a servlet we need to implement Servlet Interface or we need to extend HttpServlet
GenericServlet. That means servlet is forcing us to use Servlets specific interface or classes.


-----------------------------------------------------------------------------------------------

-> Spring Framework released in 2004 (First Production Released)
-> The current version of Spring is 5. version (Released in 2017)
Note: Reactive Programming support added in Spring Framwork 5. version
Note: Spring Boot 1.x released in 2014
-› The current version of Spring Boot is 3.0 version
Note: Spring Boot is an extension for Spring Framework.

------------------------------------------------------------------------------------------------

Spring Core
=› Spring Core is base module in Spring Framework
=› All the other modules of Spring are developed on top of Spring Core only
=› Spring Core providing fundamental concepts of Spring Framework
(IOC Container & Dependency Injection)
=> Spring Core is all about Managing dependencies among the classes


-> If we want Spring Core Module to manage dependencies among the classes with loosely coupling then we
have to develop our classes by following some best practises.
-> Spring Core suggesting Developers to follow "Strategy Design Pattern" to develop classes so that
"Spring Core" can easily manage dependencies among the classes with loosely coupling.

------------------------------------------------------------------------------------------------------------------------


++++++++++++++++++++++++++++++++++++++++++++++++
What is @Bean annotation
++++++++++++++++++++++++++++++++++++++++++++++++





> @Bean is a method level annotation
→ When we want to customize any object creation then we will use @Bean annotation for that
@Configuration
public class AppSecurity {
public AppSecurity () {
System.out.printin("AppSecurity :: Constructor");
}
@Bean
public AppSecurity createinstance() {
custom lose t so pour cuntionally
return as;


How to represent our java class as a spring bean
**************************************************

@Component
@Service
@Repository
@Controller
@RestController
@Configuration
@Bean




- All the above annotations are class level annotations but @Bean is method level annotation
- @Component is a general purpose annotation to represent java class as Spring Bean
@Service annotation is a specialization of @Component annotation. This is also used to represent java c
bean. It is allowing for implementation classes to be autodetected through classpath scanning.
- @ Repository annotation is a specialization of @Component annotaton. This is also used to represent jar
spring bean. It is having Data Access Exception translation
Ex: For dao classes we will use @Repository
Pullupfor





++++++++++++++++++++++++++++++++++++++++++++++++
What is @Bean annotation
++++++++++++++++++++++++++++++++++++++++++++++++





> @Bean is a method level annotation
→ When we want to customize any object creation then we will use @Bean annotation for that
@Configuration
public class AppSecurity {
public AppSecurity () {
System.out.printin("AppSecurity :: Constructor");
}
@Bean
public AppSecurity createinstance() {
custom lose t so pour cuntionally
return as;


How to represent our java class as a spring bean
**************************************************

@Component
@Service
@Repository
@Controller
@RestController
@Configuration
@Bean


- All the above annotations are class level annotations but @Bean is method level annotation
- @Component is a general purpose annotation to represent java class as Spring Bean
@Service annotation is a specialization of @Component annotation. This is also used to represent java c
bean. It is allowing for implementation classes to be autodetected through classpath scanning.
- @ Repository annotation is a specialization of @Component annotaton. This is also used to represent jar
spring bean. It is having Data Access Exception translation
Ex: For dao classes we will use @Repository


-> In Web applications to represent java class as controller we will use @Controller annotation. It is used for C2B
communication.  (Spring boot to UI)
for
- In Distributed application to represent java class as distributed component we will use @RestController ann. It is used
B2B communication. (Spring boot to Spring boot)



-> Autowiring is used to perform dependency injection
The process of injecting one class object into another class object is called as dependency injection.
> In Spring framework IOC container will perform dependency injection
> We will provide instructions to IOC to perform DI in 2 ways
1) Manual Wiring (using ref attribute in beans config xml file)
2) Autowiring
- Autowiring means IOC will identify dependent object and it will inject into target object

→ Autowiring will use below modes to perform Dependency Injection
------------------------------------------------------------------
1) byName
2) byType
3) constructor (internally it will use by Type only)


- To perform Autowiring we will use @Autowired annotation
-----------------------------------------------------------
> @Autowired annotation we can use at 3 places in the program
1) variable level (Field injection - FI)
2) setter method level (Setter Injection - SI)
3) constructor (Constructor Injection - CI)

@Autowired with Field Injection
+++++++++++++++++++++++
-> IOC will use Reflection api to internally to perform Field Injection


Note: Field Injection is not recommended because it is violation oops principles and it breaks Single Responsibilit
Principles.




if interface have multiple implementations to auto wiring we can go with 
@Primary
@Qualifier("asdfa")


SI vs CI vs FI
+++++++++++++
-> Setter Injection will be performed through setter method
-> It is mandatory to specify @Autowired annoation at setter method
-> If we don't specify @Autowired annotation then DI will not happen (Partial Injection)
-> If DI not happend then if we call methods then we will get NullPointerException
-> Target Bean will be created first then setter method will be called to inject dependent


Constructor injection will be performed through constructor
-> If we have more than one constructor then we have to specify @Autowired at constructor level
-> If we have only one parameterized constructor then @Autowired is optional
-> In Cl, dependent bean will be created first then target bean will be created
-> Partial Injection is not possible in CI


Fieldinjection will be performed through Reflection API
+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-> FI violating OOPS principles (private variable getting initialized from outside using Reflecion)
-> It is simple to use

++++++++++++++++
Bean Life Cycle
++++++++++++++++
> The java class which represented as Spring Bean is called as Bean Class
- The java class which is managed by IOC is called as Spring Bean
- Spring Beans life cycle will be managed by lOC
- For Spring Beans Obj creation and Obj destruction will be taken by IOC container
- We can execute life cycle methods for Spring Bean

- In Spring Boot, we can work with Bean Lifecycle methods in 2 ways
1) By Implementing interfaces (IntializingBean & DisposableBean)
2) By Using Annotations ( @PostConstruct & @PreDestory )


**********************************************************************************************

1) What is Framework ?
2) Web Framework (Ex: Struts )
3) ORM Frameworks (Ex: Hibernate )
4) Application Development Framework (Ex : Spring)
5) Spring Framework Advantages


Spring Data JPA
+++++++++++++
-> It is used to develop persistence logic in our application.
-> The logic which is responsible to communicate with database is called as Persistence Logic
-> Already we have JDBC, Spring JDBC, Hibernate, Spring ORM to develop persistence logic
-> If we use JDBC, or Spring JDBC or Hibernate or Spring ORM then we should common logics in all DAO classes to
perform CURD Oper
-> Data JPA simplified persistence logic development by providing pre-defined interfaces with methods
-> Data JPA provided Repository methods to perform CURD operations
Note: If we use Data JPA then we don't need to write logic to perform curd operations bcz Data JPA will take care of that
-> Data JPA provideed Repository interfaces to perform CURD operations
1)CrudREpository
2)JPARepository

++++++++++++++++++++++
Hibernate Vs Data JPA
++++++++++++++++++++++
-> In Hibernate we should implement all methods to perform CRUD operations
- Data JPA providing predefined methods to perform CRUD Operations
-> In Hibernate we should boiler plate code (same code in multiple classes)
- In Data JPA we don't need to write any method because JPA Repositories providing methods for us


++++++++++++++++++
Environment Setup
++++++++++++++++++
1) MySQL Database (Server s/w)
2) MySQL Workbench (Client s/w)

Entity Class
++++++++++
- The java class which is mapped with DB table is called as Entity class
- To map java class with DB table we will use below annotations
@Entity : It represents our class as Entity class. (It is mandatory annotation)
@Table : It is used to map our class with DB Table name
Note: @Table is optional if our class name and table is same. If we don't give @Table then it will consider class name as
table name.
@ld : It represents variable mapping with primary column in table (It is mandatory annotation)
@Column : It is used to map our class variables with DB table column names
Note: @Column is optional if class variable and DB table column names are same



+++++++++++++++++++++
Datasource properties
+++++++++++++++++++
- Datasource properties represents with which database we want connect
- DB URL
- DB Uname
- DB Pwd
- DB Driver Class

- We will configure datasource properties in application.properties file or application.yml file
spring.datasource.url=jdbc:mysql://localhost:3306/sbms
spring.datasource.username=ashokit
spring.datasource.password=AshokIT@123
spring.datasource.driver-class-name=com.mysql.jdbc.Driver


Native SQL Vs HQL
++++++++++++++++++
-> Native SQL queries are DB dependent
-> HQL Queries are DB in-dependent

-> Native Queries will use table name and column names in the query directley
-> HQL queris will use 'Entity Class Name' and 'Entity Class Variable Names' in the query

-> Native SQL queries will execute in Database Directley
-> HQL queries can't execute in DB directley (HQL queries will be converted to SQL query using Dialect class before execution)

-> As SQL queries are executing directley, performance wise they are good. HQL queries should be converted before execution hence
HQL queries will take more time than SQL queries.

-> Performance wise SQL queries are good
-> Maintenence wise HQL queies are good

++++++++
Sorting
++++++++
→ Sorting is used to sort the records either in ascending or in descending order
→> We can pass Sort object as parameter for findAll () method like below
List<User> users = repository.findAll();
List<User> users = repository.findAll(Sort.by("age").ascending());
List<User> users = repository.findAll(Sort.by"username", "age").descending());
users.forEach(user -> {
System.out.printin(user);
}

+++++++++++
Pagination
+++++++++++
→ The process of dividing all the records into multiple pages is called as Pagination
> If we retrieve all the records at once then performance issues we will get in the application
→ When we have lot of data in table to display then we will divide those records into multiple pages and we will display in front-end
Data will be displayed based on below 2 conditions
=> PAGE NUMBER (User landed on which page)
=> PAGE SIZE (How many records should be displayed in single page)

int pageSize = 3;
int pageNo = 0;
PageRequest pageRequest = PageRequest.of(pageNo, pageSize);
Page<User> pageData = repository.findAll(pagerequest);

int totalPages = pageData.getTotalPages);
System.out.printin("Total Pages :: "+ totalPages);

List<User> users = pageData.getContent();
users.forEach(user -> {
System.out.printin(user);
});


++++++++++++++++++++++++++
Query By Example (QBE)
+++++++++++++++++++++++++++
- It is used to prepare the query dynamically
» To implement Dynamic Search Option we can use QBE concept
User entity = new User();
entity.setCountry("India");
entity.setAge(25);
Example<User> example = Example.of(entity);
List<User> users = repository.findAll(example);
users.forEach(user → {
System.out.printin(user);}


public class Product {
@ld
@Column(name = "PRODUCT_ID")
private Integer pid;

@Column(name = "PRODUCT_NAME")
private String pname;

@Column(name = "PRODUCT_PRICE")
private Double price;

@CreationTimestamp
@Column(name = "CREATED_DATE", updatable = false)
private LocalDateTime createdDate;

@UpdateTimestamp
@Column(name = "UPDATED_DATE", updatable = false)
private LocalDateTime updatedDate;
}


++++++++++++
Primary Keys
+++++++++++
> Primary Key is a constraint (rule)
-> Primary constraint is the combination of below 2 constraints
1) UNIQUE
2) NOT NULL
-> When we use PRIMARY KEY constraint for a column then that column value shouldn't be null and it should be unique.
- It is not recommended to set values for Primary Key columns manually
-> We will use Generators to generate the value for primary key column


- In MYSQL Database we will use auto_increment to generate value for primary key. To specify auto_increment we will
use IDENTITY generator.
@ld
@Column(name = "PRODUCT_ID")
@GeneratedValue(strategy=GenerationType.IDENTITY)
private Integer pid;


- In Oracle database we will use sequence concept to generate value for primary key column. For every primary key one
sequence will be created in database


-> In MYSQL Database we will use auto increment to generate value for primary key. To specify auto _increment we will
use IDENTITY generator.
@Id
@Column(name = "PRODUCT_ID")
@GeneratedValue(strategy=Generation Type.IDENTITY)
private Integer pid;

-> In Oracle database we will use sequence concept to generate value for primary key column. For every primary key one
sequence will be created in database


@EmbeddedId
class AccPk {
accNumber;
accld;
accType;
}
@Entity
@Table
class Account {
holderName;
holderEmail;
holderAadhar;
@Embeddable
AccountPk accPk;
}

++++++++++++++++++++++++++
TX management in Data JPA
++++++++++++++++++++++++++
-> Unit amount of work is called as Transaction
-> When we are performing non select operation we need to deal with Transactions
- For select operations transaction is not required
- In Data JPA it is care of transaction managment
- If all operations are successful then we should commit transaction
- If any operation is failed in the transaction then we need to rollback that transaction
- When we are working with transactions we need to ACID properties
A - Atomacity
C - Consistency
I - Isolation
D - Durability

User user = new User();
user.setUserName("Suresh");
user.setUserEmail("suresh@gmail.com");
long size = Files.size(Paths.get(imagePath));
byte[] arr = new byte[(int) size];
FilelnputStream fis = new FilenputStream(new File(imagePath));
fis.read(arr);
fis.close();
user.setUserlmage(arr);
userRepo.save(user);
I

++++++++++++++++
Spring Web MVC
++++++++++++++++
→> Spring Web MVC is one module available in the spring framework
> Using Spring Web MVC module we can develop 2 types of applications
1) Web Applications
2) Distributed Application
→> Web Applications will have user interface (UI)
> Customers can access web applications directley using internet
-> Web Applications meant for customer to business communication
Ex: facebook, gmail, linkedin, naukri etc...


- Distributed Applications are meant for Business to Business Communication
- If one application is communicating with another application then we call them as Distributed apps
→ Distributed Applications we can develop in 2 ways
1) SOAP Webservices
2) RESTFul Services
Note: SOAP Webservices & RESTFul Services can be developed using Spring Web MVC
→ Distributed applications we are developing to re-use logic of one application in another application.


††++++++++++++++++++++
Advantages of Spring Web MVC
†+++++++++++++++++++++++
1) Easily we can develop web & distributed applications
2) It supports Multiple Presentation Technologies (JSP & Thymeleaf)
3) | 18 N Support




++++++++++++++++++++++++
Spring Web MVC Architecture
++++++++++++++++++++++++++
1) Dispatcher Servlet (Front Controller)
2) Handler Mapper
3) Controller
4) Model And View
5) ViewResolver
6) View


→ DispatcherServlet is a pre-defined servlet class in Spring Web MVC
-> Dispatcherserviet Is called Front Controller/Framework Servelet
-> It is responsible to perform pre-processing and post-processing for every request


- HandlerMapper is a pre-defined class in spring web mvc
- HandlerMapper is used to identify Request Handler
→ It will identify which request should be processed by which Controller class.

- Model represents Data in Key-Value pair
-> View represents presentation file name
→ To display data in view file we will use ModelAndView object

→ ViewResolver is used to identify where view files available in our project

→ View component is used to render model data on view file to display that to end user


+++++++++++++++
Spring Web MVC
+++++++++++++++
> Spring Web MVC is one module available in the spring framework
-> Using Spring Web MVC module we can develop 2 types of applications
1) Web Applications I
2) Distributed Application


> Web Applications will have user interface (UI)
-> Customers can access web applications directley using internet
-> Web Applications meant for customer to business communication (C 2 B)
Ex: facebook, gmail, linkedin, naukri etc...


→ Distributed Applications are meant for Business to Business Communication (B 2 B)
-> If one application is communicating with another application then we call them as Distributed apps


+++++++++++++++++++++++++++++++++++++++++++
Building First Web Application using Spring Web MVC
+++++++++++++++++++++++++++++++++++++++++++
1) Create Spring Starter application with below dependencies.
a) spring-boot-starter-web
b) tomcat-embed-jasper
c) devtools
2) Create Controller class and write Required methods.
3) Create View Files with Presentation logic.
4) Configure ViewResolver in application.properties file.
5) Run the application and test it.
 
Note-1: web-starter will provide the support to build web apps with MVC architecture and it provides To
embedded container.

Note-2: tomcat-embed-jasper will provide the support to work with JSP files in Spring Web MVC.

Note-3 : devtools is used to re-start the server when changes happend in the code.

Note-4 : Java class will be represented as a Spring Controller using @Controller annotation.

Note-5 : Controller class methods should be binded to HTTP Protocol methods to handle HTTP Requests.

++++++++++++++
HTTP requests 
++++++++++++++
1.GET
2.POST
3.PUT
4.DELETE



> GET request is used to retrieve data from Server / Provider application.
- GET request will not have body to send data in the request
-> To send any data using GET request then we will use Path Params & Query Params
Ex: https://www.youtube.com/watch?v=V0818de8sdk
Note: Path Params & Query Params data will be displayed in the URL
Note: It is not recommended to send sensitive / secret data using Path Params & Query Params
-> GET request is Idempotent (means if you send same GET request for multiple times also nothing will change at server)


-> POST request is used to create alnew record at server
-> When consumer wants to send huge data/ sensitive data then Consumer will use POST request
-> POST request contains request body
-> POST request is Non-Idempotent


-> PUT request is used to update a record at server
- When consumer wants to update a record at then consumer will send PUT request to Provider
> PUT request contains request body
-> PUT request is Idempotent
Note: In PUT request we can send data in URL and in Request Body
Note: Request Body is the recommended approach to send sensitive data to server


-> DELETE request is used to delete a record at server
-> DELETE request contains request body
-> DELETE request is Idempotent
Note: In DELETE request we can send data in URL and in Request Body.

#################
HTTP Status Codes
##################
→ HTTP Status codes will represent the status of our request & response
1xx (100 - 199) ---> INFO
2xx (200 - 299) --> OK (success)
3xx (300 - 399) ---> Redirect
4xx (400 - 499) ---> Client Error
5xx (500 - 599) -> Server Error

#######################
HTTP Request Structure
#######################
1) Intial Request Line (HTTP method + URL)
2) Request Headers (key-value )
3) Blank Line to seperate Header & Body
4) Request Body (Request Pay load)


#######################
HTTP Response Structure
#######################
1) Initial Response line(Protocol Version + Status Code + Status msg)
2) Response Headers (Key-value)
3) Blank Line to seperate Header & Body
4) Response Body (Response Pay load)


What is Disributed Application
What is Intereoperability
What is HTTP Protocol
HTTP Methods
HTTP Status Codes
HTTP Request Structure
HTTP Response Structure
Working with XML and JAX-B
Working with JSON and Jackson


++++++++++++++++++++++++
How to develop REST API
++++++++++++++++++++++++
→ To develop RESFul Services/ REST APIs using java SUN Microsystem released 'JAX-RS' API
→> JAX-RS api having 2 implementations
                1) Jersey (Sun Microsystems)
                2) REST Easy(JBOSS)
Note: We can develop RESTFul Services using any one of the above implementation
Subscribed

-> Spring framework also provided support to develop RESTFul Services using Spring Web MVC module.
+++++++++++++++++++++++++
RESTFul Services Architecture
+++++++++++++++++++++++++
-> We will have 2 actors in RESTful services
1) Provider / Resource
2) Consumer / Client
-> The application which is providing services to other applications is called as Provider or Resource application
-> The application which is accessing services from other applications is called as Consumer or Client application


- Client application and Resource application will exchange data in intereoperable format (like XML & JSON)
                  request
client app <----------------->resource app
		response
 


++++++++++++++++++++++++++
Develop First REST API Using Spring Boot
+++++++++++++++++++++++++++++++++++

1) Create Spring starter application with below dependencies
a) web-starter
b) devtools
2) Create RestController with Required methods
Note: To represent java class as Rest Controller we will use @RestController annotation
Note: Every RestController method should be binded to HTTP Protocol method
                 Ex: @GetMapping, @PostMapping, @PutMapping & @DeleteMapping
3) Run the application and test it.
Note: To test REST APIs we will use POSTMAN tool

++++++++++++++
Query Params
++++++++++++++
- Query Params are used to send data to server in URL directly
> Query Params will represent data in key-value format
-> Query Params will start with '?'
- Query Parameters will be seperated by '&'
-> Query Parameters should present only at the end of the URL
Ex: www.ashokit.in/courses?name=SBMS&trainer=Ashok
→ To read Query Parameters from the URL we will use @RequestParam annotation


+++++++++++++++++++++++++++++
Path Parameter or URI variables
+++++++++++++++++++++++++++++
- Path Parameters are also used to send data to server in URL
- Path Params will represent data directley in URL (no keys)
- Path Params can present anywhere in the URL
-> Path Params will be seperated by / (slash)
-> Path Params should be represented in Method URL pattern (Template Pattern)
Ex: www.ashokit.in/courses/{cname}/{trainerAtname}

++++++++++++++++++++++++++++
Path Parameter or URI variables
++++++++++++++++++++++++++
> Path Parameters are also used to send data to server in URL
-> Path Params will represent data directley in URL (no keys)
- Path Params can present anywhere in the URL
-> Path Params will be seperated by / (slash)
-> Path Params should be represented in Method URL pattern (Template Pattern)
Ex: www.ashokit.in/courses/{cname}/trainer/{tname}
- To read Path Parameters we will use @PathVariable annotation


################
What is Produces
#################
→ "produces" is a media type
> It represens the response formats supported by REST Controller Method
-> One Rest Controller method can support multiple response formats (xml and json) I
- Client should send a request with "Accept" http header
-> Accept header represents in which format client expecting response
- Based on Accept header Message Converter will convert the response and it will send to client as Http Response obj


################################
Working with HTTP POST Request
################################
> HTTP POST request is used to create new resource/record at server
> POST request contains request body
- Client can send data to server in Request Body
→ To bind Rest Controller method to POST request we willl use @PostMapping
- To read data from Requet body we will use @RequestBody annotation
> "consumes" represents in which formats method can take input
- "Content-Type" header represents in which format client sending data in request body.


> produces vs consumes
> Content-Type vs Accept
> produces attribute represents in which formats Method can provide response data to clients
> consumes attribute represents in which formats Method can take request data from clients
- Accept header represents in which format client expecting response from REST API T
> Content-Type header represents in which format client is sending request data to REST API


Note: We can use both Consumes & Produces in single REST API method.



What is RestController ?
REST Controller Methods
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
Query Params
Request Body
Response Body
@RequestParam
@Requesably
produces
consumes
Accept
Content-Type

Q) Can we write the logic to update a record in POST request method ?
Ans) Yes, we can do it but not recommended. We need to follow HTTP Protocol standards while developing REST API.

@ImportResource -> To link the spring bean cfg file (xml) with
@Configuration class
@Import
- To link the one @Configuration with other
@Configuration class
@PropertySource or @PropertySoruces -> To confugure one or
multiple properites files to spring


Using @Value
==============================
@Value"${hotel.name'")
private String name;
@Value("S(hotel.id)")
private Integer id;
@Value("$(hotel.location)")
private String location;
@Value("${customer.name)")
private String customerName;
@Value("#(menu.dosaPrice+ menu.idlyPrice+)
private Float billAmount;
private Float discount;
private
Float finalBillAmount;
I/gets system property value
private String osName;
//get env.. variable value
private String pathData;



Using @ConfigurationProperties
==============================
Component"comp")
pucondiaur companerties(prefix="org.nit")
private String name;
private String addrs;
private long ince;

=> To make Bean method generated spring bean belonging to certain profile.. we can add Profile on top of Bean method
in @Configuration class
@Bean(name="c3pODs")
@Profile("test")
public DataSource createC3PODs(){
}
@Profile is applicable either class level or method level
note:: if no @Profile(- is placed on top stereotype annotations based spring bean or @Bean methods
then that spring bean works for all profiles. generally we do this for service, controller lasses





































































